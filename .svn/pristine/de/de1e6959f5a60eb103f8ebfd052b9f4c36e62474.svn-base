package fr.eurecom.mobserv.arianna.model;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;

import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;


/**
 * 
 * if you want to add a field for a model in DB you must add:
 * 	1 string COLUMN_NAME_FIELD
 *  and update:
 * 	1 save()
 * 	2 constructor from cursor
 *  3 constructor standard
 * 	4 getter/setter
 *  5 string SQL_CREATE_TABLE
 *  6 string COLUMNS_NAME
 */
public abstract class Model {
	/*
	 * Maps to store object already retrieving from DB
	 */
	private static Map<String, Map<String, Model>> instances = new HashMap<String, Map<String, Model>>();
	static {
		instances.put(Event.TABLE_NAME, new HashMap<String, Model>());
		instances.put(MapLevel.TABLE_NAME, new HashMap<String, Model>());
		instances.put(NavigationNode.TABLE_NAME, new HashMap<String, Model>());
		instances.put(NavigationLink.TABLE_NAME, new HashMap<String, Model>());
		instances.put(Category.TABLE_NAME, new HashMap<String, Model>());
		instances.put(PointOfInterest.TABLE_NAME, new HashMap<String, Model>());
		instances.put(Path.TABLE_NAME, new HashMap<String, Model>());
	};

	/*
	 * DATABASE PROPERTIES
	 */
	public static final int DATABASE_VERSION = 1;
	public static final String DATABASE_NAME = "Arianna.db";

	/*
	 * SQL SYNTAX CONSTANTS
	 */
	public static final String COMMA_SEP = ", ";
	public static final String TEXT_TYPE = " TEXT";
	public static final String INT_TYPE = " INTEGER";
	public static final String UNIQUE = " UNIQUE";
	public static final String COORDINATE_TYPE = " INTEGER";
	public static final String PRIMARY_KEY = " INTEGER PRIMARY KEY";// AUTOINCREMENT

	/*
	 * MODEL PROPERTIES COLUMN NAME
	 */
	public static final String COLUMN_NAME_URI = "uri";

	/*
	 * ADDITIONAL TABLES
	 */
	public static final String TABLE_NAME_POI_PATH_RELATION = "poi_path_relation";
	public static final String COLUMN_NAME_PATH_URI = "path_uri";
	public static final String COLUMN_NAME_POI_URI = "poi_uri";
	public static final String COLUMN_NAME_POSITION = "position";

	public static final String SQL_CREATE_TABLE_POI_PATH_RELATION = "CREATE TABLE "
			+ Model.TABLE_NAME_POI_PATH_RELATION
			+ " ("
			+ Model.COLUMN_NAME_PATH_URI+ Model.TEXT_TYPE+ Model.COMMA_SEP
			+ Model.COLUMN_NAME_POI_URI+ Model.TEXT_TYPE+ Model.COMMA_SEP
			+ Model.COLUMN_NAME_POSITION + Model.INT_TYPE + Model.COMMA_SEP
			+ "FOREIGN KEY("+ Model.COLUMN_NAME_PATH_URI+ ") REFERENCES "+ Path.TABLE_NAME+ "("+ Model.COLUMN_NAME_URI+ ")"
			+ COMMA_SEP
			+ "FOREIGN KEY("
			+ Model.COLUMN_NAME_POI_URI
			+ ") REFERENCES "
			+ PointOfInterest.TABLE_NAME
			+ "("
			+ Model.COLUMN_NAME_URI
			+ ")"
			+ COMMA_SEP
			+ "PRIMARY KEY("
			+ Model.COLUMN_NAME_PATH_URI
			+ COMMA_SEP + Model.COLUMN_NAME_POI_URI + ")" + ")";

	public static final String TABLE_NAME_POI_ATTRIBUTE = "poi_attribute";
	public static final String COLUMN_NAME_ATTRIBUTE_KEY = "attribute_key";
	public static final String COLUMN_NAME_ATTRIBUTE_VALUE = "attribute_value";

	public static final String SQL_CREATE_TABLE_POI_ATTRIBUTE = "CREATE TABLE "
			+ Model.TABLE_NAME_POI_ATTRIBUTE + " (" + Model.COLUMN_NAME_POI_URI
			+ Model.TEXT_TYPE + Model.COMMA_SEP
			+ Model.COLUMN_NAME_ATTRIBUTE_KEY + Model.TEXT_TYPE
			+ Model.COMMA_SEP + Model.COLUMN_NAME_ATTRIBUTE_VALUE
			+ Model.TEXT_TYPE + Model.COMMA_SEP + "FOREIGN KEY("
			+ Model.COLUMN_NAME_POI_URI + ") REFERENCES "
			+ PointOfInterest.TABLE_NAME + "(" + Model.COLUMN_NAME_URI + ")"
			+ COMMA_SEP + "PRIMARY KEY(" + Model.COLUMN_NAME_POI_URI
			+ COMMA_SEP + Model.COLUMN_NAME_ATTRIBUTE_KEY + ")" + ")";

	/*
	 * GENERAL DROP STATEMENT
	 */
	public static final String SQL_DROP_TABLE = "DROP TABLE IF EXISTS ";

	/*
	 * MODEL PROPERTIES
	 */
	private Context context;

	private String uri;

	/**
	 * @author uccio
	 */

	/* Array with all the create table statements */
	public static ArrayList<String> SQLCreateTableStatements = new ArrayList<String>();

	static {
		SQLCreateTableStatements.add(Event.SQL_CREATE_TABLE);
		SQLCreateTableStatements.add(MapLevel.SQL_CREATE_TABLE);
		SQLCreateTableStatements.add(NavigationNode.SQL_CREATE_TABLE);
		SQLCreateTableStatements.add(NavigationLink.SQL_CREATE_TABLE);
		SQLCreateTableStatements.add(PointOfInterest.SQL_CREATE_TABLE);
		SQLCreateTableStatements.add(Path.SQL_CREATE_TABLE);
		SQLCreateTableStatements.add(Category.SQL_CREATE_TABLE);
		SQLCreateTableStatements.add(Model.SQL_CREATE_TABLE_POI_PATH_RELATION);
		SQLCreateTableStatements.add(Model.SQL_CREATE_TABLE_POI_ATTRIBUTE);
	}

	/* Array with all the drop table statements */
	public static ArrayList<String> SQLDropTableStatements = new ArrayList<String>();

	static {
		SQLDropTableStatements.add(Model.SQL_DROP_TABLE + Event.TABLE_NAME);
		SQLDropTableStatements.add(Model.SQL_DROP_TABLE + MapLevel.TABLE_NAME);
		SQLDropTableStatements.add(Model.SQL_DROP_TABLE
				+ NavigationNode.TABLE_NAME);
		SQLDropTableStatements.add(Model.SQL_DROP_TABLE
				+ NavigationLink.TABLE_NAME);
		SQLDropTableStatements.add(Model.SQL_DROP_TABLE
				+ PointOfInterest.TABLE_NAME);
		SQLDropTableStatements.add(Model.SQL_DROP_TABLE + Path.TABLE_NAME);
		SQLDropTableStatements.add(Model.SQL_DROP_TABLE + Category.TABLE_NAME);
		SQLDropTableStatements.add(Model.SQL_DROP_TABLE
				+ Model.TABLE_NAME_POI_PATH_RELATION);
		SQLDropTableStatements.add(Model.SQL_DROP_TABLE
				+ Model.TABLE_NAME_POI_ATTRIBUTE);
	}

	public Model(Context context, String uri) {
		this.context = context;
		this.uri = uri;
	}

	/**
	 * Method for retrieving a model given its unique URI
	 * 
	 * @param uri
	 * @return the model requested
	 */
	public static Model getByURI(Class<?> classname, String uri, Context context) {
		Map<String, Model> elements = null;
		Model model = null;
		try {
			/** try to select object from objects already loaded **/
			elements = instances.get((String) classname.getDeclaredField(
					"TABLE_NAME").get(null));
			model = elements.get(uri);
		} catch (IllegalArgumentException e1) {
			e1.printStackTrace();
		} catch (IllegalAccessException e1) {
			e1.printStackTrace();
		} catch (NoSuchFieldException e1) {
			e1.printStackTrace();
		}

		if (model == null) {
			SQLiteDatabase db = DbHelper.getInstance(context)
					.getReadableDatabase();
			try {
				// get field declared as TABLE_NAME from specific model class
				String table = (String) classname
						.getDeclaredField("TABLE_NAME").get(null);
				// projection null in order to return all columns
				// get field declared as COLUMNS_NAME from specific class of a
				// model, it is an array containing all column names to select
				String[] projection = (String[]) classname.getField(
						"COLUMNS_NAME").get(null);
				// Define 'where' part of query.
				String selection = Model.COLUMN_NAME_URI + "=?";
				// Specify arguments in placeholder order.
				String[] selectionArgs = { uri };
				Cursor cur = db.query(table, // The table to query
						projection, // The columns to return
						selection, // The columns for the WHERE clause
						selectionArgs, // The values for the WHERE clause
						null, // don't group the rows
						null, // don't filter by row groups
						null // The sort order
						);

				cur.moveToFirst();
				// Retrieve the right constructor for the specific class of a
				// model
				Constructor<?> constructor = classname
						.getConstructor(new Class[] { Context.class,
								Cursor.class });
				model = (Model) constructor.newInstance(context, cur);
				elements.put(model.getUri(), model);
			} catch (IllegalArgumentException e) {
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				e.printStackTrace();
			} catch (NoSuchFieldException e) {
				e.printStackTrace();
			} catch (NoSuchMethodException e) {
				e.printStackTrace();
			} catch (InstantiationException e) {
				e.printStackTrace();
			} catch (InvocationTargetException e) {
				e.printStackTrace();
			}
		}
		return model;
	}

	public static Map<String, ? extends Model> getByParam(Class<?> classname,
			String paramName, String paramValue, Context context) {
		Map<String, Model> mapModels = new HashMap<String, Model>();
		SQLiteDatabase db = DbHelper.getInstance(context).getReadableDatabase();
		Map<String, Model> elements = null;
		Model model = null;
		// get field declared as TABLE_NAME from specific model class
		String table;
		try {
			table = (String) classname.getDeclaredField("TABLE_NAME").get(null);
			// projection null in order to return all columns
			String[] projection = (String[]) classname.getField("COLUMNS_NAME")
					.get(null);
			// Define 'where' part of query.
			String selection = paramName + "=?";
			// Specify arguments in placeholder order.
			String[] selectionArgs = { paramValue };
			Cursor cur = db.query(table, // The table to query
					projection, // The columns to return
					selection, // The columns for the WHERE clause
					selectionArgs, // The values for the WHERE clause
					null, // don't group the rows
					null, // don't filter by row groups
					null // The sort order
					);
			cur.moveToFirst();
			// Retrieve the right constructor for the specific class of a
			// model
			Constructor<?> constructor = classname.getConstructor(new Class[] {
					Context.class, Cursor.class });
			while (cur.isAfterLast() == false) {
				String uri = cur.getString(cur
						.getColumnIndex(Model.COLUMN_NAME_URI));
				/** try to select object from objects already loaded **/
				elements = instances.get((String) classname.getDeclaredField(
						"TABLE_NAME").get(null));
				model = elements.get(uri);
				if (model == null)
					model = (Model) constructor.newInstance(context, cur);
				mapModels.put(model.getUri(), model);
				cur.moveToNext();
			}

		} catch (IllegalArgumentException e) {

			e.printStackTrace();
		} catch (IllegalAccessException e) {

			e.printStackTrace();
		} catch (NoSuchFieldException e) {

			e.printStackTrace();
		} catch (NoSuchMethodException e) {

			e.printStackTrace();
		} catch (InstantiationException e) {

			e.printStackTrace();
		} catch (InvocationTargetException e) {

			e.printStackTrace();
		}

		return mapModels;
	}

	/**
	 * Save or update the entity on the db
	 * 
	 * @return false on failure, true on success
	 */
	public abstract boolean save();

	/**
	 * Delete the entity from the db
	 * 
	 * @return false on failure, true on success
	 */
	public boolean delete() {
		SQLiteDatabase db = DbHelper.getInstance(context).getWritableDatabase();
		String whereClause = COLUMN_NAME_URI + " = ?";
		String[] whereArgs = { this.getUri() };
		int numRowAffected = db.delete(this.getTableName(), whereClause,
				whereArgs);

		if (numRowAffected != 1) {
			return false;
		}
		return true;
	}

	protected abstract String getTableName();

	/**
	 * Used by Model.save when entry is already in the db
	 * 
	 * @return false on failure, true on success
	 */
	protected boolean update() {

		// TODO implementare update
		return false;
	}

	/********************************************************
	 * * GETTER AND SETTERS * *
	 ********************************************************/

	public Context getContext() {
		return context;
	}

	public void setContext(Context context) {
		this.context = context;
	}

	public String getUri() {
		return uri;
	}

	public void setUri(String uri) {
		this.uri = uri;
	}

	/********************************************************
	 * * EQUALS AND HASHCODE * *
	 ********************************************************/

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.lang.Object#hashCode()
	 */
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((context == null) ? 0 : context.hashCode());
		result = prime * result + ((uri == null) ? 0 : uri.hashCode());
		return result;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.lang.Object#equals(java.lang.Object)
	 */
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Model other = (Model) obj;
		if (context == null) {
			if (other.context != null)
				return false;
		} else if (!context.equals(other.context))
			return false;
		if (uri == null) {
			if (other.uri != null)
				return false;
		} else if (!uri.equals(other.uri))
			return false;
		return true;
	}
	
	/** compute all paths from a source 
	 * *
	 * @param source
	 */
	public static void computePaths(NavigationNode source) {
		source.minDistance = 0.;
		PriorityQueue<NavigationNode> vertexQueue = new PriorityQueue<NavigationNode>();
		vertexQueue.add(source);

		while (!vertexQueue.isEmpty()) {
			NavigationNode u = vertexQueue.poll();

			// Visit each edge exiting u
			for (NavigationLink e : u.getOutLinks().values()) {
				NavigationNode v = e.getToNode();
				double weight = e.getWeight();
				double distanceThroughU = u.minDistance + weight;
				if (distanceThroughU < v.minDistance) {
					vertexQueue.remove(v);
					v.minDistance = distanceThroughU;
					v.previous = u;
					vertexQueue.add(v);
				}
			}
		}
	}
	
	/**
	 * give shortest path between 2 two nodes
	 * @param from
	 * @param to
	 * @return
	 */
	public static List<NavigationNode> getShortestPath(NavigationNode from, NavigationNode to) {
		//computePaths(from);
		computePath(from,to);
		List<NavigationNode> path = new ArrayList<NavigationNode>();
		for (NavigationNode vertex = to; vertex != null; vertex = vertex.previous)
			path.add(vertex);
		Collections.reverse(path);
		
		return path;
	}
	
	public static List<NavigationLink> getShortestPathLink(NavigationNode from, NavigationNode to) {
		//computePaths(from);
		computePath(from,to);
//		List<NavigationNode> path = new ArrayList<NavigationNode>();
		List<NavigationLink> path = new LinkedList<NavigationLink>();
		for (NavigationNode vertex = to; vertex != from; vertex = vertex.previous)
			path.add(vertex.linkToPrevious);
		Collections.reverse(path);
		return path;
	}
	
	public static void computePath(NavigationNode source,NavigationNode target) {
		source.minDistance = 0.;
		PriorityQueue<NavigationNode> vertexQueue = new PriorityQueue<NavigationNode>();
		vertexQueue.add(source);

		while (!vertexQueue.isEmpty()) {
			NavigationNode u = vertexQueue.poll();
			if (u.equals(target))
		    	break;
			// Visit each edge exiting u
			for (NavigationLink e : u.getOutLinks().values()) {
				NavigationNode v = e.getToNode();
				double weight = e.getWeight();
				double distanceThroughU = u.minDistance + weight;
				if (distanceThroughU < v.minDistance) {
					vertexQueue.remove(v);
					v.minDistance = distanceThroughU;
					v.previous = u;
					v.linkToPrevious = e;
					vertexQueue.add(v);
				}
			}
		}
	}
	
}
